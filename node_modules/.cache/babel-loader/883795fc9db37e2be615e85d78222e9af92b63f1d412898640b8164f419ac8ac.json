{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport * as d3 from 'd3';\nconst ThiessenLayer = ({\n  stations,\n  bounds\n}) => {\n  _s();\n  const map = useMap();\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(layer => layer.options && layer.options.className === 'thiessen-layer');\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n    try {\n      // Convert stations to pixel coordinates\n      const points = stations.map(station => {\n        const point = map.latLngToLayerPoint([station.lat, station.lng]);\n        return [point.x, point.y];\n      });\n\n      // Calculate bounds in pixel coordinates\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n\n      // Ensure bounds are valid (minX < maxX and minY < maxY)\n      const voronoiBounds = [Math.min(minPoint.x, maxPoint.x), Math.min(minPoint.y, maxPoint.y), Math.max(minPoint.x, maxPoint.x), Math.max(minPoint.y, maxPoint.y)];\n\n      // Add padding to bounds\n      const padding = 50;\n      voronoiBounds[0] -= padding;\n      voronoiBounds[1] -= padding;\n      voronoiBounds[2] += padding;\n      voronoiBounds[3] += padding;\n\n      // Create Voronoi diagram\n      const delaunay = d3.Delaunay.from(points);\n      const voronoi = delaunay.voronoi(voronoiBounds);\n\n      // Create polygons for each station\n      const polygons = stations.map((station, i) => {\n        const cell = voronoi.cellPolygon(i);\n        if (!cell) return null;\n\n        // Convert cell points back to LatLng\n        const latLngs = cell.map(point => {\n          const layerPoint = L.point(point[0], point[1]);\n          return map.layerPointToLatLng(layerPoint);\n        });\n\n        // Create polygon with station's precipitation value\n        const polygon = L.polygon(latLngs, {\n          color: '#666',\n          weight: 2,\n          fillColor: getColorForPrecipitation(station.precipitation),\n          fillOpacity: 0.5,\n          className: 'thiessen-polygon'\n        });\n\n        // Add popup with station info\n        polygon.bindPopup(`\n          <div>\n            <h3 class=\"font-bold\">${station.name || `Station ${i + 1}`}</h3>\n            <p>Precipitation: ${station.precipitation} mm</p>\n          </div>\n        `);\n        return polygon;\n      }).filter(Boolean);\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(polygons, {\n        className: 'thiessen-layer'\n      }).addTo(map);\n\n      // Update polygons when map is zoomed or moved\n      const updatePolygons = () => {\n        // Convert stations to new pixel coordinates\n        const updatedPoints = stations.map(station => {\n          const point = map.latLngToLayerPoint([station.lat, station.lng]);\n          return [point.x, point.y];\n        });\n\n        // Update bounds\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        const updatedMaxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n        const updatedBounds = [Math.min(updatedMinPoint.x, updatedMaxPoint.x) - padding, Math.min(updatedMinPoint.y, updatedMaxPoint.y) - padding, Math.max(updatedMinPoint.x, updatedMaxPoint.x) + padding, Math.max(updatedMinPoint.y, updatedMaxPoint.y) + padding];\n\n        // Create new Voronoi diagram\n        const updatedDelaunay = d3.Delaunay.from(updatedPoints);\n        const updatedVoronoi = updatedDelaunay.voronoi(updatedBounds);\n\n        // Update polygon positions\n        polygons.forEach((polygon, i) => {\n          const cell = updatedVoronoi.cellPolygon(i);\n          if (!cell) return;\n          const latLngs = cell.map(point => {\n            const layerPoint = L.point(point[0], point[1]);\n            return map.layerPointToLatLng(layerPoint);\n          });\n          polygon.setLatLngs(latLngs);\n        });\n      };\n      map.on('zoomend moveend', updatePolygons);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updatePolygons);\n      };\n    } catch (error) {\n      console.error('Error creating Thiessen polygons:', error);\n    }\n  }, [map, stations, bounds]);\n  return null;\n};\n\n// Helper function to get color based on precipitation value\n_s(ThiessenLayer, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function () {\n  return [useMap];\n});\n_c = ThiessenLayer;\nfunction getColorForPrecipitation(precipitation) {\n  if (precipitation < 50) return '#3B82F6'; // blue\n  if (precipitation < 100) return '#10B981'; // green\n  if (precipitation < 150) return '#F59E0B'; // yellow\n  return '#EF4444'; // red\n}\nexport default ThiessenLayer;\nvar _c;\n$RefreshReg$(_c, \"ThiessenLayer\");","map":{"version":3,"names":["useEffect","useMap","L","d3","ThiessenLayer","stations","bounds","_s","map","length","existingLayer","_layers","Object","values","find","layer","options","className","removeLayer","points","station","point","latLngToLayerPoint","lat","lng","x","y","minPoint","minLat","minLng","maxPoint","maxLat","maxLng","voronoiBounds","Math","min","max","padding","delaunay","Delaunay","from","voronoi","polygons","i","cell","cellPolygon","latLngs","layerPoint","layerPointToLatLng","polygon","color","weight","fillColor","getColorForPrecipitation","precipitation","fillOpacity","bindPopup","name","filter","Boolean","layerGroup","addTo","updatePolygons","updatedPoints","updatedMinPoint","updatedMaxPoint","updatedBounds","updatedDelaunay","updatedVoronoi","forEach","setLatLngs","on","off","error","console","_c","$RefreshReg$"],"sources":["/home/deepak-silaych/Desktop/sem6/ce343/src/components/ThiessenLayer.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport * as d3 from 'd3';\n\nconst ThiessenLayer = ({ stations, bounds }) => {\n  const map = useMap();\n\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(\n      layer => layer.options && layer.options.className === 'thiessen-layer'\n    );\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n\n    try {\n      // Convert stations to pixel coordinates\n      const points = stations.map(station => {\n        const point = map.latLngToLayerPoint([station.lat, station.lng]);\n        return [point.x, point.y];\n      });\n\n      // Calculate bounds in pixel coordinates\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n\n      // Ensure bounds are valid (minX < maxX and minY < maxY)\n      const voronoiBounds = [\n        Math.min(minPoint.x, maxPoint.x),\n        Math.min(minPoint.y, maxPoint.y),\n        Math.max(minPoint.x, maxPoint.x),\n        Math.max(minPoint.y, maxPoint.y)\n      ];\n\n      // Add padding to bounds\n      const padding = 50;\n      voronoiBounds[0] -= padding;\n      voronoiBounds[1] -= padding;\n      voronoiBounds[2] += padding;\n      voronoiBounds[3] += padding;\n\n      // Create Voronoi diagram\n      const delaunay = d3.Delaunay.from(points);\n      const voronoi = delaunay.voronoi(voronoiBounds);\n\n      // Create polygons for each station\n      const polygons = stations.map((station, i) => {\n        const cell = voronoi.cellPolygon(i);\n        if (!cell) return null;\n\n        // Convert cell points back to LatLng\n        const latLngs = cell.map(point => {\n          const layerPoint = L.point(point[0], point[1]);\n          return map.layerPointToLatLng(layerPoint);\n        });\n\n        // Create polygon with station's precipitation value\n        const polygon = L.polygon(latLngs, {\n          color: '#666',\n          weight: 2,\n          fillColor: getColorForPrecipitation(station.precipitation),\n          fillOpacity: 0.5,\n          className: 'thiessen-polygon'\n        });\n\n        // Add popup with station info\n        polygon.bindPopup(`\n          <div>\n            <h3 class=\"font-bold\">${station.name || `Station ${i + 1}`}</h3>\n            <p>Precipitation: ${station.precipitation} mm</p>\n          </div>\n        `);\n\n        return polygon;\n      }).filter(Boolean);\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(polygons, {\n        className: 'thiessen-layer'\n      }).addTo(map);\n\n      // Update polygons when map is zoomed or moved\n      const updatePolygons = () => {\n        // Convert stations to new pixel coordinates\n        const updatedPoints = stations.map(station => {\n          const point = map.latLngToLayerPoint([station.lat, station.lng]);\n          return [point.x, point.y];\n        });\n\n        // Update bounds\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        const updatedMaxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n\n        const updatedBounds = [\n          Math.min(updatedMinPoint.x, updatedMaxPoint.x) - padding,\n          Math.min(updatedMinPoint.y, updatedMaxPoint.y) - padding,\n          Math.max(updatedMinPoint.x, updatedMaxPoint.x) + padding,\n          Math.max(updatedMinPoint.y, updatedMaxPoint.y) + padding\n        ];\n\n        // Create new Voronoi diagram\n        const updatedDelaunay = d3.Delaunay.from(updatedPoints);\n        const updatedVoronoi = updatedDelaunay.voronoi(updatedBounds);\n\n        // Update polygon positions\n        polygons.forEach((polygon, i) => {\n          const cell = updatedVoronoi.cellPolygon(i);\n          if (!cell) return;\n\n          const latLngs = cell.map(point => {\n            const layerPoint = L.point(point[0], point[1]);\n            return map.layerPointToLatLng(layerPoint);\n          });\n\n          polygon.setLatLngs(latLngs);\n        });\n      };\n\n      map.on('zoomend moveend', updatePolygons);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updatePolygons);\n      };\n    } catch (error) {\n      console.error('Error creating Thiessen polygons:', error);\n    }\n  }, [map, stations, bounds]);\n\n  return null;\n};\n\n// Helper function to get color based on precipitation value\nfunction getColorForPrecipitation(precipitation) {\n  if (precipitation < 50) return '#3B82F6';  // blue\n  if (precipitation < 100) return '#10B981'; // green\n  if (precipitation < 150) return '#F59E0B'; // yellow\n  return '#EF4444';                         // red\n}\n\nexport default ThiessenLayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}