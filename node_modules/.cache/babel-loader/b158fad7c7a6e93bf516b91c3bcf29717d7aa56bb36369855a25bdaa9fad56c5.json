{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport * as d3 from 'd3';\nconst ThiessenLayer = ({\n  stations,\n  bounds,\n  targetPoint\n}) => {\n  _s();\n  const map = useMap();\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(layer => layer.options && layer.options.className === 'thiessen-layer');\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n    try {\n      // Convert stations to pixel coordinates\n      const points = stations.map(station => {\n        const point = map.latLngToLayerPoint([station.lat, station.lng]);\n        return [point.x, point.y];\n      });\n\n      // Convert target point to pixel coordinates\n      const targetPixel = targetPoint ? map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]) : null;\n\n      // Calculate bounds in pixel coordinates\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n\n      // Ensure bounds are valid (minX < maxX and minY < maxY)\n      const voronoiBounds = [Math.min(minPoint.x, maxPoint.x), Math.min(minPoint.y, maxPoint.y), Math.max(minPoint.x, maxPoint.x), Math.max(minPoint.y, maxPoint.y)];\n\n      // Add padding to bounds\n      const padding = 50;\n      voronoiBounds[0] -= padding;\n      voronoiBounds[1] -= padding;\n      voronoiBounds[2] += padding;\n      voronoiBounds[3] += padding;\n\n      // Create Voronoi diagram\n      const delaunay = d3.Delaunay.from(points);\n      const voronoi = delaunay.voronoi(voronoiBounds);\n\n      // Find which polygon contains the target point\n      let targetPolygonIndex = -1;\n      if (targetPixel) {\n        targetPolygonIndex = delaunay.find(targetPixel.x, targetPixel.y);\n      }\n\n      // Create polygons for each station\n      const polygons = stations.map((station, i) => {\n        const cell = voronoi.cellPolygon(i);\n        if (!cell) return null;\n\n        // Convert cell points back to LatLng\n        const latLngs = cell.map(point => {\n          const layerPoint = L.point(point[0], point[1]);\n          return map.layerPointToLatLng(layerPoint);\n        });\n\n        // Create polygon with station's precipitation value\n        const isTargetPolygon = i === targetPolygonIndex;\n        const polygon = L.polygon(latLngs, {\n          color: isTargetPolygon ? '#000' : '#666',\n          weight: isTargetPolygon ? 3 : 2,\n          fillColor: getColorForPrecipitation(station.precipitation),\n          fillOpacity: isTargetPolygon ? 0.7 : 0.5,\n          className: 'thiessen-polygon'\n        });\n\n        // Add popup with station info\n        polygon.bindPopup(`\n          <div>\n            <h3 class=\"font-bold\">${station.name || `Station ${i + 1}`}</h3>\n            <p>Precipitation: ${station.precipitation} mm</p>\n            ${isTargetPolygon ? '<p class=\"font-bold text-green-600\">Contains Target Point</p>' : ''}\n          </div>\n        `);\n        return polygon;\n      }).filter(Boolean);\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(polygons, {\n        className: 'thiessen-layer'\n      }).addTo(map);\n\n      // Update polygons when map is zoomed or moved\n      const updatePolygons = () => {\n        // Convert stations to new pixel coordinates\n        const updatedPoints = stations.map(station => {\n          const point = map.latLngToLayerPoint([station.lat, station.lng]);\n          return [point.x, point.y];\n        });\n\n        // Update target point pixel coordinates\n        const updatedTargetPixel = targetPoint ? map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]) : null;\n\n        // Update bounds\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        const updatedMaxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n        const updatedBounds = [Math.min(updatedMinPoint.x, updatedMaxPoint.x) - padding, Math.min(updatedMinPoint.y, updatedMaxPoint.y) - padding, Math.max(updatedMinPoint.x, updatedMaxPoint.x) + padding, Math.max(updatedMinPoint.y, updatedMaxPoint.y) + padding];\n\n        // Create new Voronoi diagram\n        const updatedDelaunay = d3.Delaunay.from(updatedPoints);\n        const updatedVoronoi = updatedDelaunay.voronoi(updatedBounds);\n\n        // Find updated target polygon\n        let updatedTargetPolygonIndex = -1;\n        if (updatedTargetPixel) {\n          updatedTargetPolygonIndex = updatedDelaunay.find(updatedTargetPixel.x, updatedTargetPixel.y);\n        }\n\n        // Update polygon positions\n        polygons.forEach((polygon, i) => {\n          const cell = updatedVoronoi.cellPolygon(i);\n          if (!cell) return;\n          const latLngs = cell.map(point => {\n            const layerPoint = L.point(point[0], point[1]);\n            return map.layerPointToLatLng(layerPoint);\n          });\n          const isTargetPolygon = i === updatedTargetPolygonIndex;\n          polygon.setLatLngs(latLngs);\n          polygon.setStyle({\n            color: isTargetPolygon ? '#000' : '#666',\n            weight: isTargetPolygon ? 3 : 2,\n            fillOpacity: isTargetPolygon ? 0.7 : 0.5\n          });\n        });\n      };\n      map.on('zoomend moveend', updatePolygons);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updatePolygons);\n      };\n    } catch (error) {\n      console.error('Error creating Thiessen polygons:', error);\n    }\n  }, [map, stations, bounds, targetPoint]);\n  return null;\n};\n\n// Helper function to get color based on precipitation value\n_s(ThiessenLayer, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function () {\n  return [useMap];\n});\n_c = ThiessenLayer;\nfunction getColorForPrecipitation(precipitation) {\n  if (precipitation < 50) return '#3B82F6'; // blue\n  if (precipitation < 100) return '#10B981'; // green\n  if (precipitation < 150) return '#F59E0B'; // yellow\n  return '#EF4444'; // red\n}\nexport default ThiessenLayer;\nvar _c;\n$RefreshReg$(_c, \"ThiessenLayer\");","map":{"version":3,"names":["useEffect","useMap","L","d3","ThiessenLayer","stations","bounds","targetPoint","_s","map","length","existingLayer","_layers","Object","values","find","layer","options","className","removeLayer","points","station","point","latLngToLayerPoint","lat","lng","x","y","targetPixel","minPoint","minLat","minLng","maxPoint","maxLat","maxLng","voronoiBounds","Math","min","max","padding","delaunay","Delaunay","from","voronoi","targetPolygonIndex","polygons","i","cell","cellPolygon","latLngs","layerPoint","layerPointToLatLng","isTargetPolygon","polygon","color","weight","fillColor","getColorForPrecipitation","precipitation","fillOpacity","bindPopup","name","filter","Boolean","layerGroup","addTo","updatePolygons","updatedPoints","updatedTargetPixel","updatedMinPoint","updatedMaxPoint","updatedBounds","updatedDelaunay","updatedVoronoi","updatedTargetPolygonIndex","forEach","setLatLngs","setStyle","on","off","error","console","_c","$RefreshReg$"],"sources":["/home/deepak-silaych/Desktop/sem6/ce343/src/components/ThiessenLayer.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport * as d3 from 'd3';\n\nconst ThiessenLayer = ({ stations, bounds, targetPoint }) => {\n  const map = useMap();\n\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(\n      layer => layer.options && layer.options.className === 'thiessen-layer'\n    );\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n\n    try {\n      // Convert stations to pixel coordinates\n      const points = stations.map(station => {\n        const point = map.latLngToLayerPoint([station.lat, station.lng]);\n        return [point.x, point.y];\n      });\n\n      // Convert target point to pixel coordinates\n      const targetPixel = targetPoint ? \n        map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]) : null;\n\n      // Calculate bounds in pixel coordinates\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n\n      // Ensure bounds are valid (minX < maxX and minY < maxY)\n      const voronoiBounds = [\n        Math.min(minPoint.x, maxPoint.x),\n        Math.min(minPoint.y, maxPoint.y),\n        Math.max(minPoint.x, maxPoint.x),\n        Math.max(minPoint.y, maxPoint.y)\n      ];\n\n      // Add padding to bounds\n      const padding = 50;\n      voronoiBounds[0] -= padding;\n      voronoiBounds[1] -= padding;\n      voronoiBounds[2] += padding;\n      voronoiBounds[3] += padding;\n\n      // Create Voronoi diagram\n      const delaunay = d3.Delaunay.from(points);\n      const voronoi = delaunay.voronoi(voronoiBounds);\n\n      // Find which polygon contains the target point\n      let targetPolygonIndex = -1;\n      if (targetPixel) {\n        targetPolygonIndex = delaunay.find(targetPixel.x, targetPixel.y);\n      }\n\n      // Create polygons for each station\n      const polygons = stations.map((station, i) => {\n        const cell = voronoi.cellPolygon(i);\n        if (!cell) return null;\n\n        // Convert cell points back to LatLng\n        const latLngs = cell.map(point => {\n          const layerPoint = L.point(point[0], point[1]);\n          return map.layerPointToLatLng(layerPoint);\n        });\n\n        // Create polygon with station's precipitation value\n        const isTargetPolygon = i === targetPolygonIndex;\n        const polygon = L.polygon(latLngs, {\n          color: isTargetPolygon ? '#000' : '#666',\n          weight: isTargetPolygon ? 3 : 2,\n          fillColor: getColorForPrecipitation(station.precipitation),\n          fillOpacity: isTargetPolygon ? 0.7 : 0.5,\n          className: 'thiessen-polygon'\n        });\n\n        // Add popup with station info\n        polygon.bindPopup(`\n          <div>\n            <h3 class=\"font-bold\">${station.name || `Station ${i + 1}`}</h3>\n            <p>Precipitation: ${station.precipitation} mm</p>\n            ${isTargetPolygon ? '<p class=\"font-bold text-green-600\">Contains Target Point</p>' : ''}\n          </div>\n        `);\n\n        return polygon;\n      }).filter(Boolean);\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(polygons, {\n        className: 'thiessen-layer'\n      }).addTo(map);\n\n      // Update polygons when map is zoomed or moved\n      const updatePolygons = () => {\n        // Convert stations to new pixel coordinates\n        const updatedPoints = stations.map(station => {\n          const point = map.latLngToLayerPoint([station.lat, station.lng]);\n          return [point.x, point.y];\n        });\n\n        // Update target point pixel coordinates\n        const updatedTargetPixel = targetPoint ? \n          map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]) : null;\n\n        // Update bounds\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        const updatedMaxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n\n        const updatedBounds = [\n          Math.min(updatedMinPoint.x, updatedMaxPoint.x) - padding,\n          Math.min(updatedMinPoint.y, updatedMaxPoint.y) - padding,\n          Math.max(updatedMinPoint.x, updatedMaxPoint.x) + padding,\n          Math.max(updatedMinPoint.y, updatedMaxPoint.y) + padding\n        ];\n\n        // Create new Voronoi diagram\n        const updatedDelaunay = d3.Delaunay.from(updatedPoints);\n        const updatedVoronoi = updatedDelaunay.voronoi(updatedBounds);\n\n        // Find updated target polygon\n        let updatedTargetPolygonIndex = -1;\n        if (updatedTargetPixel) {\n          updatedTargetPolygonIndex = updatedDelaunay.find(\n            updatedTargetPixel.x, \n            updatedTargetPixel.y\n          );\n        }\n\n        // Update polygon positions\n        polygons.forEach((polygon, i) => {\n          const cell = updatedVoronoi.cellPolygon(i);\n          if (!cell) return;\n\n          const latLngs = cell.map(point => {\n            const layerPoint = L.point(point[0], point[1]);\n            return map.layerPointToLatLng(layerPoint);\n          });\n\n          const isTargetPolygon = i === updatedTargetPolygonIndex;\n          polygon.setLatLngs(latLngs);\n          polygon.setStyle({\n            color: isTargetPolygon ? '#000' : '#666',\n            weight: isTargetPolygon ? 3 : 2,\n            fillOpacity: isTargetPolygon ? 0.7 : 0.5\n          });\n        });\n      };\n\n      map.on('zoomend moveend', updatePolygons);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updatePolygons);\n      };\n    } catch (error) {\n      console.error('Error creating Thiessen polygons:', error);\n    }\n  }, [map, stations, bounds, targetPoint]);\n\n  return null;\n};\n\n// Helper function to get color based on precipitation value\nfunction getColorForPrecipitation(precipitation) {\n  if (precipitation < 50) return '#3B82F6';  // blue\n  if (precipitation < 100) return '#10B981'; // green\n  if (precipitation < 150) return '#F59E0B'; // yellow\n  return '#EF4444';                         // red\n}\n\nexport default ThiessenLayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}