{"ast":null,"code":"var _jsxFileName = \"/home/deepak-silaych/Desktop/sem6/ce343/src/components/IsohyetalLayer.js\",\n  _s = $RefreshSig$();\nimport React, { useMemo, useEffect } from 'react';\nimport { Polyline } from 'react-leaflet';\nimport * as d3 from 'd3-contour';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst IsohyetalLayer = ({\n  stations,\n  bounds,\n  targetPoint\n}) => {\n  _s();\n  const map = useMap();\n  const contours = useMemo(() => {\n    if (!stations || stations.length < 3) return [];\n    try {\n      // Create a grid of values using IDW interpolation\n      const gridSize = 50;\n      const dx = (bounds.maxLng - bounds.minLng) / gridSize;\n      const dy = (bounds.maxLat - bounds.minLat) / gridSize;\n      const values = new Array(gridSize * gridSize);\n\n      // Generate grid values using IDW\n      for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n          const lat = bounds.minLat + i * dy;\n          const lng = bounds.minLng + j * dx;\n          values[i * gridSize + j] = calculateIDWValue(stations, lat, lng);\n        }\n      }\n\n      // Generate contours\n      const contourGenerator = d3.contours().size([gridSize, gridSize]).thresholds(8); // Number of contour lines\n\n      const contourData = contourGenerator(values);\n\n      // Transform contour coordinates to map coordinates\n      return contourData.map(contour => ({\n        value: contour.value,\n        lines: contour.coordinates.map(line => line[0].map(point => [bounds.minLat + point[1] * dy, bounds.minLng + point[0] * dx]))\n      }));\n    } catch (error) {\n      console.error('Error generating isohyets:', error);\n      return [];\n    }\n  }, [stations, bounds]);\n  const getContourColor = value => {\n    const maxPrecip = Math.max(...stations.map(s => s.precipitation));\n    const ratio = value / maxPrecip;\n    return ratio < 0.25 ? '#3B82F6' :\n    // blue\n    ratio < 0.5 ? '#10B981' :\n    // green\n    ratio < 0.75 ? '#F59E0B' :\n    // yellow\n    '#EF4444'; // red\n  };\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(layer => layer.options && layer.options.className === 'isohyetal-layer');\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n    try {\n      // Convert stations to pixel coordinates for interpolation\n      const points = stations.map(station => ({\n        x: map.latLngToLayerPoint([station.lat, station.lng]).x,\n        y: map.latLngToLayerPoint([station.lat, station.lng]).y,\n        value: station.precipitation\n      }));\n\n      // Convert target point to pixel coordinates\n      const targetPixel = targetPoint ? {\n        x: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).x,\n        y: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).y\n      } : null;\n\n      // Calculate grid size based on bounds\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n      const width = maxPoint.x - minPoint.x;\n      const height = maxPoint.y - minPoint.y;\n      const cellSize = 10;\n      const cols = Math.ceil(width / cellSize);\n      const rows = Math.ceil(height / cellSize);\n\n      // Create grid of points for interpolation\n      const grid = new Array(rows * cols).fill(null).map((_, i) => {\n        const col = i % cols;\n        const row = Math.floor(i / cols);\n        return {\n          x: minPoint.x + col * cellSize,\n          y: minPoint.y + row * cellSize\n        };\n      });\n\n      // Interpolate values using IDW\n      const power = 2;\n      grid.forEach(point => {\n        let weightedSum = 0;\n        let weightSum = 0;\n        points.forEach(station => {\n          const dx = station.x - point.x;\n          const dy = station.y - point.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          const weight = 1 / Math.pow(distance, power);\n          weightedSum += station.value * weight;\n          weightSum += weight;\n        });\n        point.value = weightedSum / weightSum;\n      });\n\n      // Generate contours\n      const contourGenerator = d3.contours().size([cols, rows]).thresholds(d3.range(0, 200, 20)); // Generate contours every 20mm\n\n      const values = new Float64Array(grid.length);\n      grid.forEach((point, i) => {\n        values[i] = point.value;\n      });\n      const contours = contourGenerator(values);\n\n      // Find target point's contour\n      let targetContourValue = null;\n      if (targetPixel) {\n        const targetGridX = Math.floor((targetPixel.x - minPoint.x) / cellSize);\n        const targetGridY = Math.floor((targetPixel.y - minPoint.y) / cellSize);\n        const targetIndex = targetGridY * cols + targetGridX;\n        if (targetIndex >= 0 && targetIndex < grid.length) {\n          targetContourValue = Math.floor(grid[targetIndex].value / 20) * 20;\n        }\n      }\n\n      // Create layer group for all contours\n      const layers = [];\n\n      // Convert contour coordinates to LatLng and create polygons\n      contours.forEach(contour => {\n        const isTargetContour = targetContourValue !== null && Math.abs(contour.value - targetContourValue) < 10;\n        contour.coordinates.forEach(polygon => {\n          const latLngs = polygon[0].map(point => {\n            const x = minPoint.x + point[0] * cellSize;\n            const y = minPoint.y + point[1] * cellSize;\n            return map.layerPointToLatLng([x, y]);\n          });\n\n          // Create polygon for each contour\n          const layer = L.polygon(latLngs, {\n            color: isTargetContour ? '#000' : '#666',\n            weight: isTargetContour ? 3 : 1,\n            fillColor: getColorForPrecipitation(contour.value),\n            fillOpacity: isTargetContour ? 0.4 : 0.2,\n            className: 'isohyetal-contour'\n          });\n\n          // Add popup with contour value\n          layer.bindPopup(`\n            <div>\n              <h3 class=\"font-bold\">Precipitation Level</h3>\n              <p>${contour.value.toFixed(0)} mm</p>\n              ${isTargetContour ? '<p class=\"font-bold text-green-600\">Contains Target Point</p>' : ''}\n            </div>\n          `);\n          layers.push(layer);\n        });\n      });\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(layers, {\n        className: 'isohyetal-layer'\n      }).addTo(map);\n\n      // Update contours when map is zoomed or moved\n      const updateContours = () => {\n        // Recalculate all coordinates similar to initial creation\n        // This is necessary to maintain proper positioning when zooming/panning\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        layers.forEach(layer => {\n          const latLngs = layer.getLatLngs()[0].map(latLng => {\n            const point = map.latLngToLayerPoint([latLng.lat, latLng.lng]);\n            const x = (point.x - updatedMinPoint.x) / cellSize;\n            const y = (point.y - updatedMinPoint.y) / cellSize;\n            return map.layerPointToLatLng([updatedMinPoint.x + x * cellSize, updatedMinPoint.y + y * cellSize]);\n          });\n          layer.setLatLngs(latLngs);\n        });\n      };\n      map.on('zoomend moveend', updateContours);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updateContours);\n      };\n    } catch (error) {\n      console.error('Error creating isohyetal contours:', error);\n    }\n  }, [map, stations, bounds, targetPoint]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: contours.map((contour, i) => contour.lines.map((line, j) => /*#__PURE__*/_jsxDEV(Polyline, {\n      positions: line,\n      pathOptions: {\n        color: getContourColor(contour.value),\n        weight: 2,\n        opacity: 0.8\n      }\n    }, `${i}-${j}`, false, {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 11\n    }, this)))\n  }, void 0, false);\n};\n\n// Helper function to calculate IDW value at a point\n_s(IsohyetalLayer, \"sRwJ1LUofGT01HtK/ZToU9GUDh4=\", false, function () {\n  return [useMap];\n});\n_c = IsohyetalLayer;\nfunction calculateIDWValue(stations, lat, lng) {\n  let weightedSum = 0;\n  let weightSum = 0;\n  stations.forEach(station => {\n    const distance = calculateDistance(lat, lng, station.lat, station.lng);\n    if (distance === 0) return station.precipitation;\n    const weight = 1 / Math.pow(distance, 2);\n    weightedSum += station.precipitation * weight;\n    weightSum += weight;\n  });\n  return weightedSum / weightSum;\n}\nfunction calculateDistance(lat1, lon1, lat2, lon2) {\n  const R = 6371; // Earth's radius in km\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\nfunction toRad(degrees) {\n  return degrees * Math.PI / 180;\n}\n\n// Helper function to get color based on precipitation value\nfunction getColorForPrecipitation(value) {\n  // Use d3's interpolateRainbow for smooth color transitions\n  return d3.interpolateRainbow(value / 200);\n}\nexport default IsohyetalLayer;\nvar _c;\n$RefreshReg$(_c, \"IsohyetalLayer\");","map":{"version":3,"names":["React","useMemo","useEffect","Polyline","d3","useMap","L","jsxDEV","_jsxDEV","Fragment","_Fragment","IsohyetalLayer","stations","bounds","targetPoint","_s","map","contours","length","gridSize","dx","maxLng","minLng","dy","maxLat","minLat","values","Array","i","j","lat","lng","calculateIDWValue","contourGenerator","size","thresholds","contourData","contour","value","lines","coordinates","line","point","error","console","getContourColor","maxPrecip","Math","max","s","precipitation","ratio","existingLayer","_layers","Object","find","layer","options","className","removeLayer","points","station","x","latLngToLayerPoint","y","targetPixel","minPoint","maxPoint","width","height","cellSize","cols","ceil","rows","grid","fill","_","col","row","floor","power","forEach","weightedSum","weightSum","distance","sqrt","weight","pow","range","Float64Array","targetContourValue","targetGridX","targetGridY","targetIndex","layers","isTargetContour","abs","polygon","latLngs","layerPointToLatLng","color","fillColor","getColorForPrecipitation","fillOpacity","bindPopup","toFixed","push","layerGroup","addTo","updateContours","updatedMinPoint","getLatLngs","latLng","setLatLngs","on","off","children","positions","pathOptions","opacity","fileName","_jsxFileName","lineNumber","columnNumber","_c","calculateDistance","lat1","lon1","lat2","lon2","R","dLat","toRad","dLon","a","sin","cos","c","atan2","degrees","PI","interpolateRainbow","$RefreshReg$"],"sources":["/home/deepak-silaych/Desktop/sem6/ce343/src/components/IsohyetalLayer.js"],"sourcesContent":["import React, { useMemo, useEffect } from 'react';\nimport { Polyline } from 'react-leaflet';\nimport * as d3 from 'd3-contour';\nimport { useMap } from 'react-leaflet';\nimport L from 'leaflet';\n\nconst IsohyetalLayer = ({ stations, bounds, targetPoint }) => {\n  const map = useMap();\n\n  const contours = useMemo(() => {\n    if (!stations || stations.length < 3) return [];\n\n    try {\n      // Create a grid of values using IDW interpolation\n      const gridSize = 50;\n      const dx = (bounds.maxLng - bounds.minLng) / gridSize;\n      const dy = (bounds.maxLat - bounds.minLat) / gridSize;\n      const values = new Array(gridSize * gridSize);\n\n      // Generate grid values using IDW\n      for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n          const lat = bounds.minLat + (i * dy);\n          const lng = bounds.minLng + (j * dx);\n          values[i * gridSize + j] = calculateIDWValue(stations, lat, lng);\n        }\n      }\n\n      // Generate contours\n      const contourGenerator = d3.contours()\n        .size([gridSize, gridSize])\n        .thresholds(8); // Number of contour lines\n\n      const contourData = contourGenerator(values);\n\n      // Transform contour coordinates to map coordinates\n      return contourData.map(contour => ({\n        value: contour.value,\n        lines: contour.coordinates.map(line => \n          line[0].map(point => [\n            bounds.minLat + (point[1] * dy),\n            bounds.minLng + (point[0] * dx)\n          ])\n        )\n      }));\n    } catch (error) {\n      console.error('Error generating isohyets:', error);\n      return [];\n    }\n  }, [stations, bounds]);\n\n  const getContourColor = (value) => {\n    const maxPrecip = Math.max(...stations.map(s => s.precipitation));\n    const ratio = value / maxPrecip;\n    return ratio < 0.25 ? '#3B82F6' :  // blue\n           ratio < 0.5 ? '#10B981' :   // green\n           ratio < 0.75 ? '#F59E0B' :  // yellow\n           '#EF4444';                  // red\n  };\n\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(\n      layer => layer.options && layer.options.className === 'isohyetal-layer'\n    );\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n\n    try {\n      // Convert stations to pixel coordinates for interpolation\n      const points = stations.map(station => ({\n        x: map.latLngToLayerPoint([station.lat, station.lng]).x,\n        y: map.latLngToLayerPoint([station.lat, station.lng]).y,\n        value: station.precipitation\n      }));\n\n      // Convert target point to pixel coordinates\n      const targetPixel = targetPoint ? {\n        x: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).x,\n        y: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).y\n      } : null;\n\n      // Calculate grid size based on bounds\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n      const width = maxPoint.x - minPoint.x;\n      const height = maxPoint.y - minPoint.y;\n      const cellSize = 10;\n      const cols = Math.ceil(width / cellSize);\n      const rows = Math.ceil(height / cellSize);\n\n      // Create grid of points for interpolation\n      const grid = new Array(rows * cols).fill(null).map((_, i) => {\n        const col = i % cols;\n        const row = Math.floor(i / cols);\n        return {\n          x: minPoint.x + col * cellSize,\n          y: minPoint.y + row * cellSize\n        };\n      });\n\n      // Interpolate values using IDW\n      const power = 2;\n      grid.forEach(point => {\n        let weightedSum = 0;\n        let weightSum = 0;\n        points.forEach(station => {\n          const dx = station.x - point.x;\n          const dy = station.y - point.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          const weight = 1 / Math.pow(distance, power);\n          weightedSum += station.value * weight;\n          weightSum += weight;\n        });\n        point.value = weightedSum / weightSum;\n      });\n\n      // Generate contours\n      const contourGenerator = d3.contours()\n        .size([cols, rows])\n        .thresholds(d3.range(0, 200, 20)); // Generate contours every 20mm\n\n      const values = new Float64Array(grid.length);\n      grid.forEach((point, i) => {\n        values[i] = point.value;\n      });\n\n      const contours = contourGenerator(values);\n\n      // Find target point's contour\n      let targetContourValue = null;\n      if (targetPixel) {\n        const targetGridX = Math.floor((targetPixel.x - minPoint.x) / cellSize);\n        const targetGridY = Math.floor((targetPixel.y - minPoint.y) / cellSize);\n        const targetIndex = targetGridY * cols + targetGridX;\n        if (targetIndex >= 0 && targetIndex < grid.length) {\n          targetContourValue = Math.floor(grid[targetIndex].value / 20) * 20;\n        }\n      }\n\n      // Create layer group for all contours\n      const layers = [];\n\n      // Convert contour coordinates to LatLng and create polygons\n      contours.forEach(contour => {\n        const isTargetContour = targetContourValue !== null && \n          Math.abs(contour.value - targetContourValue) < 10;\n\n        contour.coordinates.forEach(polygon => {\n          const latLngs = polygon[0].map(point => {\n            const x = minPoint.x + point[0] * cellSize;\n            const y = minPoint.y + point[1] * cellSize;\n            return map.layerPointToLatLng([x, y]);\n          });\n\n          // Create polygon for each contour\n          const layer = L.polygon(latLngs, {\n            color: isTargetContour ? '#000' : '#666',\n            weight: isTargetContour ? 3 : 1,\n            fillColor: getColorForPrecipitation(contour.value),\n            fillOpacity: isTargetContour ? 0.4 : 0.2,\n            className: 'isohyetal-contour'\n          });\n\n          // Add popup with contour value\n          layer.bindPopup(`\n            <div>\n              <h3 class=\"font-bold\">Precipitation Level</h3>\n              <p>${contour.value.toFixed(0)} mm</p>\n              ${isTargetContour ? '<p class=\"font-bold text-green-600\">Contains Target Point</p>' : ''}\n            </div>\n          `);\n\n          layers.push(layer);\n        });\n      });\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(layers, {\n        className: 'isohyetal-layer'\n      }).addTo(map);\n\n      // Update contours when map is zoomed or moved\n      const updateContours = () => {\n        // Recalculate all coordinates similar to initial creation\n        // This is necessary to maintain proper positioning when zooming/panning\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        \n        layers.forEach(layer => {\n          const latLngs = layer.getLatLngs()[0].map(latLng => {\n            const point = map.latLngToLayerPoint([latLng.lat, latLng.lng]);\n            const x = (point.x - updatedMinPoint.x) / cellSize;\n            const y = (point.y - updatedMinPoint.y) / cellSize;\n            return map.layerPointToLatLng([\n              updatedMinPoint.x + x * cellSize,\n              updatedMinPoint.y + y * cellSize\n            ]);\n          });\n          layer.setLatLngs(latLngs);\n        });\n      };\n\n      map.on('zoomend moveend', updateContours);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updateContours);\n      };\n    } catch (error) {\n      console.error('Error creating isohyetal contours:', error);\n    }\n  }, [map, stations, bounds, targetPoint]);\n\n  return (\n    <>\n      {contours.map((contour, i) => \n        contour.lines.map((line, j) => (\n          <Polyline\n            key={`${i}-${j}`}\n            positions={line}\n            pathOptions={{\n              color: getContourColor(contour.value),\n              weight: 2,\n              opacity: 0.8\n            }}\n          >\n          </Polyline>\n        ))\n      )}\n    </>\n  );\n};\n\n// Helper function to calculate IDW value at a point\nfunction calculateIDWValue(stations, lat, lng) {\n  let weightedSum = 0;\n  let weightSum = 0;\n\n  stations.forEach(station => {\n    const distance = calculateDistance(lat, lng, station.lat, station.lng);\n    if (distance === 0) return station.precipitation;\n\n    const weight = 1 / Math.pow(distance, 2);\n    weightedSum += station.precipitation * weight;\n    weightSum += weight;\n  });\n\n  return weightedSum / weightSum;\n}\n\nfunction calculateDistance(lat1, lon1, lat2, lon2) {\n  const R = 6371; // Earth's radius in km\n  const dLat = toRad(lat2 - lat1);\n  const dLon = toRad(lon2 - lon1);\n  const a = \n    Math.sin(dLat/2) * Math.sin(dLat/2) +\n    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * \n    Math.sin(dLon/2) * Math.sin(dLon/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  return R * c;\n}\n\nfunction toRad(degrees) {\n  return degrees * Math.PI / 180;\n}\n\n// Helper function to get color based on precipitation value\nfunction getColorForPrecipitation(value) {\n  // Use d3's interpolateRainbow for smooth color transitions\n  return d3.interpolateRainbow(value / 200);\n}\n\nexport default IsohyetalLayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}