{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect } from 'react';\nimport { useMap } from 'react-leaflet';\nimport { contours } from 'd3-contour';\nimport L from 'leaflet';\nconst IsohyetalLayer = ({\n  stations,\n  bounds,\n  targetPoint\n}) => {\n  _s();\n  const map = useMap();\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(layer => layer.options && layer.options.className === 'isohyetal-layer');\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n    try {\n      // Convert stations to pixel coordinates for interpolation\n      const points = stations.map(station => ({\n        x: map.latLngToLayerPoint([station.lat, station.lng]).x,\n        y: map.latLngToLayerPoint([station.lat, station.lng]).y,\n        value: station.precipitation\n      }));\n\n      // Convert target point to pixel coordinates\n      const targetPixel = targetPoint ? {\n        x: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).x,\n        y: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).y\n      } : null;\n\n      // Calculate grid size based on bounds\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n      const width = maxPoint.x - minPoint.x;\n      const height = maxPoint.y - minPoint.y;\n      const cellSize = 10;\n      const cols = Math.ceil(width / cellSize);\n      const rows = Math.ceil(height / cellSize);\n\n      // Create grid of points for interpolation\n      const grid = new Array(rows * cols).fill(null).map((_, i) => {\n        const col = i % cols;\n        const row = Math.floor(i / cols);\n        return {\n          x: minPoint.x + col * cellSize,\n          y: minPoint.y + row * cellSize\n        };\n      });\n\n      // Interpolate values using IDW\n      const power = 2;\n      grid.forEach(point => {\n        let weightedSum = 0;\n        let weightSum = 0;\n        points.forEach(station => {\n          const dx = station.x - point.x;\n          const dy = station.y - point.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance === 0) {\n            point.value = station.value;\n            return;\n          }\n          const weight = 1 / Math.pow(distance, power);\n          weightedSum += station.value * weight;\n          weightSum += weight;\n        });\n        if (!point.value) {\n          point.value = weightedSum / weightSum;\n        }\n      });\n\n      // Generate contours\n      const thresholds = [];\n      for (let i = 0; i <= 200; i += 20) {\n        thresholds.push(i);\n      }\n      const contourGenerator = contours().size([cols, rows]).thresholds(thresholds);\n      const values = new Float64Array(grid.length);\n      grid.forEach((point, i) => {\n        values[i] = point.value;\n      });\n      const contourData = contourGenerator(values);\n\n      // Find target point's contour\n      let targetContourValue = null;\n      if (targetPixel) {\n        const targetGridX = Math.floor((targetPixel.x - minPoint.x) / cellSize);\n        const targetGridY = Math.floor((targetPixel.y - minPoint.y) / cellSize);\n        const targetIndex = targetGridY * cols + targetGridX;\n        if (targetIndex >= 0 && targetIndex < grid.length) {\n          targetContourValue = Math.floor(grid[targetIndex].value / 20) * 20;\n        }\n      }\n\n      // Create layer group for all contours\n      const layers = [];\n\n      // Convert contour coordinates to LatLng and create polygons\n      contourData.forEach(contour => {\n        const isTargetContour = targetContourValue !== null && Math.abs(contour.value - targetContourValue) < 10;\n        contour.coordinates.forEach(polygon => {\n          const latLngs = polygon[0].map(point => {\n            const x = minPoint.x + point[0] * cellSize;\n            const y = minPoint.y + point[1] * cellSize;\n            return map.layerPointToLatLng([x, y]);\n          });\n\n          // Create polygon for each contour\n          const layer = L.polygon(latLngs, {\n            color: isTargetContour ? '#000' : '#666',\n            weight: isTargetContour ? 3 : 1,\n            fillColor: getColorForPrecipitation(contour.value),\n            fillOpacity: isTargetContour ? 0.4 : 0.2,\n            className: 'isohyetal-contour'\n          });\n\n          // Add popup with contour value\n          layer.bindPopup(`\n            <div>\n              <h3 class=\"font-bold\">Precipitation Level</h3>\n              <p>${contour.value.toFixed(0)} mm</p>\n              ${isTargetContour ? '<p class=\"font-bold text-green-600\">Contains Target Point</p>' : ''}\n            </div>\n          `);\n          layers.push(layer);\n        });\n      });\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(layers, {\n        className: 'isohyetal-layer'\n      }).addTo(map);\n\n      // Update contours when map is zoomed or moved\n      const updateContours = () => {\n        // Recalculate all coordinates similar to initial creation\n        // This is necessary to maintain proper positioning when zooming/panning\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        layers.forEach(layer => {\n          const latLngs = layer.getLatLngs()[0].map(latLng => {\n            const point = map.latLngToLayerPoint([latLng.lat, latLng.lng]);\n            const x = (point.x - updatedMinPoint.x) / cellSize;\n            const y = (point.y - updatedMinPoint.y) / cellSize;\n            return map.layerPointToLatLng([updatedMinPoint.x + x * cellSize, updatedMinPoint.y + y * cellSize]);\n          });\n          layer.setLatLngs(latLngs);\n        });\n      };\n      map.on('zoomend moveend', updateContours);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updateContours);\n      };\n    } catch (error) {\n      console.error('Error creating isohyetal contours:', error);\n    }\n  }, [map, stations, bounds, targetPoint]);\n  return null;\n};\n\n// Helper function to get color based on precipitation value\n_s(IsohyetalLayer, \"IoceErwr5KVGS9kN4RQ1bOkYMAg=\", false, function () {\n  return [useMap];\n});\n_c = IsohyetalLayer;\nfunction getColorForPrecipitation(value) {\n  if (value < 50) return '#3B82F6'; // blue\n  if (value < 100) return '#10B981'; // green\n  if (value < 150) return '#F59E0B'; // yellow\n  return '#EF4444'; // red\n}\nexport default IsohyetalLayer;\nvar _c;\n$RefreshReg$(_c, \"IsohyetalLayer\");","map":{"version":3,"names":["useEffect","useMap","contours","L","IsohyetalLayer","stations","bounds","targetPoint","_s","map","length","existingLayer","_layers","Object","values","find","layer","options","className","removeLayer","points","station","x","latLngToLayerPoint","lat","lng","y","value","precipitation","targetPixel","minPoint","minLat","minLng","maxPoint","maxLat","maxLng","width","height","cellSize","cols","Math","ceil","rows","grid","Array","fill","_","i","col","row","floor","power","forEach","point","weightedSum","weightSum","dx","dy","distance","sqrt","weight","pow","thresholds","push","contourGenerator","size","Float64Array","contourData","targetContourValue","targetGridX","targetGridY","targetIndex","layers","contour","isTargetContour","abs","coordinates","polygon","latLngs","layerPointToLatLng","color","fillColor","getColorForPrecipitation","fillOpacity","bindPopup","toFixed","layerGroup","addTo","updateContours","updatedMinPoint","getLatLngs","latLng","setLatLngs","on","off","error","console","_c","$RefreshReg$"],"sources":["/home/deepak-silaych/Desktop/sem6/ce343/src/components/IsohyetalLayer.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useMap } from 'react-leaflet';\nimport { contours } from 'd3-contour';\nimport L from 'leaflet';\n\nconst IsohyetalLayer = ({ stations, bounds, targetPoint }) => {\n  const map = useMap();\n\n  useEffect(() => {\n    if (!stations || stations.length < 3 || !bounds) return;\n\n    // Remove existing layer if any\n    const existingLayer = map._layers && Object.values(map._layers).find(\n      layer => layer.options && layer.options.className === 'isohyetal-layer'\n    );\n    if (existingLayer) {\n      map.removeLayer(existingLayer);\n    }\n\n    try {\n      // Convert stations to pixel coordinates for interpolation\n      const points = stations.map(station => ({\n        x: map.latLngToLayerPoint([station.lat, station.lng]).x,\n        y: map.latLngToLayerPoint([station.lat, station.lng]).y,\n        value: station.precipitation\n      }));\n\n      // Convert target point to pixel coordinates\n      const targetPixel = targetPoint ? {\n        x: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).x,\n        y: map.latLngToLayerPoint([targetPoint.lat, targetPoint.lng]).y\n      } : null;\n\n      // Calculate grid size based on bounds\n      const minPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n      const maxPoint = map.latLngToLayerPoint([bounds.maxLat, bounds.maxLng]);\n      const width = maxPoint.x - minPoint.x;\n      const height = maxPoint.y - minPoint.y;\n      const cellSize = 10;\n      const cols = Math.ceil(width / cellSize);\n      const rows = Math.ceil(height / cellSize);\n\n      // Create grid of points for interpolation\n      const grid = new Array(rows * cols).fill(null).map((_, i) => {\n        const col = i % cols;\n        const row = Math.floor(i / cols);\n        return {\n          x: minPoint.x + col * cellSize,\n          y: minPoint.y + row * cellSize\n        };\n      });\n\n      // Interpolate values using IDW\n      const power = 2;\n      grid.forEach(point => {\n        let weightedSum = 0;\n        let weightSum = 0;\n        points.forEach(station => {\n          const dx = station.x - point.x;\n          const dy = station.y - point.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance === 0) {\n            point.value = station.value;\n            return;\n          }\n          const weight = 1 / Math.pow(distance, power);\n          weightedSum += station.value * weight;\n          weightSum += weight;\n        });\n        if (!point.value) {\n          point.value = weightedSum / weightSum;\n        }\n      });\n\n      // Generate contours\n      const thresholds = [];\n      for (let i = 0; i <= 200; i += 20) {\n        thresholds.push(i);\n      }\n\n      const contourGenerator = contours()\n        .size([cols, rows])\n        .thresholds(thresholds);\n\n      const values = new Float64Array(grid.length);\n      grid.forEach((point, i) => {\n        values[i] = point.value;\n      });\n\n      const contourData = contourGenerator(values);\n\n      // Find target point's contour\n      let targetContourValue = null;\n      if (targetPixel) {\n        const targetGridX = Math.floor((targetPixel.x - minPoint.x) / cellSize);\n        const targetGridY = Math.floor((targetPixel.y - minPoint.y) / cellSize);\n        const targetIndex = targetGridY * cols + targetGridX;\n        if (targetIndex >= 0 && targetIndex < grid.length) {\n          targetContourValue = Math.floor(grid[targetIndex].value / 20) * 20;\n        }\n      }\n\n      // Create layer group for all contours\n      const layers = [];\n\n      // Convert contour coordinates to LatLng and create polygons\n      contourData.forEach(contour => {\n        const isTargetContour = targetContourValue !== null && \n          Math.abs(contour.value - targetContourValue) < 10;\n\n        contour.coordinates.forEach(polygon => {\n          const latLngs = polygon[0].map(point => {\n            const x = minPoint.x + point[0] * cellSize;\n            const y = minPoint.y + point[1] * cellSize;\n            return map.layerPointToLatLng([x, y]);\n          });\n\n          // Create polygon for each contour\n          const layer = L.polygon(latLngs, {\n            color: isTargetContour ? '#000' : '#666',\n            weight: isTargetContour ? 3 : 1,\n            fillColor: getColorForPrecipitation(contour.value),\n            fillOpacity: isTargetContour ? 0.4 : 0.2,\n            className: 'isohyetal-contour'\n          });\n\n          // Add popup with contour value\n          layer.bindPopup(`\n            <div>\n              <h3 class=\"font-bold\">Precipitation Level</h3>\n              <p>${contour.value.toFixed(0)} mm</p>\n              ${isTargetContour ? '<p class=\"font-bold text-green-600\">Contains Target Point</p>' : ''}\n            </div>\n          `);\n\n          layers.push(layer);\n        });\n      });\n\n      // Create layer group and add to map\n      const layerGroup = L.layerGroup(layers, {\n        className: 'isohyetal-layer'\n      }).addTo(map);\n\n      // Update contours when map is zoomed or moved\n      const updateContours = () => {\n        // Recalculate all coordinates similar to initial creation\n        // This is necessary to maintain proper positioning when zooming/panning\n        const updatedMinPoint = map.latLngToLayerPoint([bounds.minLat, bounds.minLng]);\n        \n        layers.forEach(layer => {\n          const latLngs = layer.getLatLngs()[0].map(latLng => {\n            const point = map.latLngToLayerPoint([latLng.lat, latLng.lng]);\n            const x = (point.x - updatedMinPoint.x) / cellSize;\n            const y = (point.y - updatedMinPoint.y) / cellSize;\n            return map.layerPointToLatLng([\n              updatedMinPoint.x + x * cellSize,\n              updatedMinPoint.y + y * cellSize\n            ]);\n          });\n          layer.setLatLngs(latLngs);\n        });\n      };\n\n      map.on('zoomend moveend', updateContours);\n\n      // Cleanup\n      return () => {\n        map.removeLayer(layerGroup);\n        map.off('zoomend moveend', updateContours);\n      };\n    } catch (error) {\n      console.error('Error creating isohyetal contours:', error);\n    }\n  }, [map, stations, bounds, targetPoint]);\n\n  return null;\n};\n\n// Helper function to get color based on precipitation value\nfunction getColorForPrecipitation(value) {\n  if (value < 50) return '#3B82F6';  // blue\n  if (value < 100) return '#10B981'; // green\n  if (value < 150) return '#F59E0B'; // yellow\n  return '#EF4444';                  // red\n}\n\nexport default IsohyetalLayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}